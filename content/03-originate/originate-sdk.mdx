---
title: With the SDK
description: Originating assets with the Polymesh SDK
slug: /originate/sdk
tags: technical
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';
import HighlightBox from "../../src/components/HighlightBox"

In the previous exercise, we originated a simple asset, ACME Corp equity. As we did so, we discovered that there are many more **configurable properties** available to address common business requirements.

The Polymesh Dashboard is constructed with the SDK. The SDK supports every process you see there, and more. Use the SDK to build integrations with internal systems. Fortunately, the SDK's methods are intelligible when you know what it is you intend to do.

<HighlightBox type="tip">

If you want to take a closer look at the SDK, a peek into the
[SDK documentation](https://developers.polymath.network/classic-sdk/globals) is recommendable.

</HighlightBox>

The SDK is a comprehensive set of business-level methods for inspecting and interacting with the Polymesh network using either Javascript or Typescript, at the developer's discretion.

You can find it here [@polymathnetwork/polymesh-sdk](https://www.npmjs.com/package/@polymathnetwork/polymesh-sdk)

## Preconditions

If you went through the Quick Start, we can assume that you have created an account (a public-private key pair) on the Polymesh Testnet, that you associated it with an account, and that you credited it with POLYX. We shall call this personal signing key `aliceKey`, and the personal account it represents `alice`.

Here, we are going to follow along the Token Studio Dashboard exercise, and do the same _mistake_. whereby she creates the token with her personal account, and which we will eventually fix. The credible simple reason why Alice created the token with her personal account is that her and her co-founders wanted to act fast so as to have the ticker available before getting the company through CDD.

To recap:

* Alice, ACME's CEO and acting agent, already has an **individual** Polymesh account, named `alice`, tied to a primary private key named `aliceKey`;
* `aliceKey`'s private key is based on the `"word1 word2 ..."` mnemonic;
* A Polymesh client has been [instantiated](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#static-connect) by Alice so she can do the next actions:
    <MultiCodeBlock>

    ```typescript
    const apiAlice: Polymesh = await Polymesh.connect({
        "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    ```javascript
    const apiAlice = await Polymesh.connect({
        "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
        "accountMnemonic": "word1 word2 ..."
    });
    ```

    </MultiCodeBlock>

## Ticker reservation

Before creating the token proper, Alice needs to [reserve](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#reserveticker) the ACME ticker so that it is not squatted while the founders incorporate the company. Think of it on the same level as grabbing your `.com` domain as early as possible:

<MultiCodeBlock>

```typescript
const reservationQueue: TransactionQueue<TickerReservation> = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

```javascript
const reservationQueue = await apiAlice.reserveTicker({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

The `TransactionQueue` type is just that, a queue. The transaction(s) in it have not been launched. Notice that:

* It is a generic type parameterised with `TickerReservation`. This means that, eventually, the queue yields an instance of `TickerReservation`;
* The constructor of `TransactionQueue` expects a [`context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#constructor); it is in this `context` object that `apiAlice` is referenced so it is understood that `aliceKey` is the private key to use for signing;
* Each transaction in the queue has its own status;
* The queue itself has its own [status](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#status).

<HighlightBox type="info">

Of note, the reservation cost, at the time of writing, is of **2,500 POLYX**, before network fees.

</HighlightBox>

Let's [run](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#run) it.

<MultiCodeBlock>

```typescript
const reservation: TickerReservation = await reservationQueue.run();
```

```javascript
const reservation = await reservationQueue.run();
```

</MultiCodeBlock>

It is at this point that the necessary signatures are collected for the transactions. `apiAlice` was created straight with the mnemonic, so the signature will be affixed automatically. However, if this was taking place in the browser, for instance in the Token Studio Dashboard and with the Polymesh Wallet extension, then there is a possibility that Alice will refuse to sign when prompted.

<HighlightBox type="tip">

You would need to `try .run() catch` it for errors. Here, we opted for clarity and omitted this _detail_.

</HighlightBox>

Also note that with `await reservationQueue.run()` we patiently wait for the queue to finalise all its transactions. However, a `TransactionQueue` can provide intermediate information about its changing status and that of its component transactions. If this is of interest to you, you can pass callbacks to [`onStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#onstatuschange) and [`onTransactionStatusChange`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/transactionqueue#ontransactionstatuschange).

At this stage, Alice owns the reservation. You can confirm it with the following:

<MultiCodeBlock>

```typescript
const alice: Identity = await apiAlice.getCurrentIdentity();
const details: TickerReservationDetails = await reservation.details();
const owner: Identity = details.owner;
assert(owner.did === alice.did);
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const { owner } = await reservation.details();
assert(owner.did === alice.did);
```

</MultiCodeBlock>

Something is not immediately apparent from the few lines of code above. It is nonetheless important to point it out.

When we created `apiAlice` with `await Polymesh.connect()`, we passed an identifier `accountMnemonic` that allowed the SDK to recreate the `aliceKey` private key. At the risk of repeating what was covered in the introduction module, this private key is not the Polymesh account proper, nor is it the public key. The public key is associated with an account, whether as a primary key, like here, or a secondary one. When the private key is used to sign a transaction, it is the **associated account** that will be considered to be the one doing the action.

This associated account information is **not embedded in the private key**. It is an association that is stored on the blockchain, may change in the future, and as such, it needs to be retrieved to be known.

<HighlightBox type="info">

So when we wrote `await` in `await apiAlice.getCurrentIdentity()`, this is no accident. We indeed need to do a round trip to the blockchain to know what account our public key is associated with.

</HighlightBox>

## Ticker creation

Now that the ticker is reserved, it is time to issue the security token.

Oh wait! The reservation may have happened some time ago. After all a reservation remains valid for 60 days, for instance. And your `const reservation: TickerReservation` instance might no longer be in memory.

How do you get it back? Use [`getTickerReservation`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/polymesh#gettickerreservation):

<MultiCodeBlock>

```typescript
const apiAlice: Polymesh = await Polymesh.connect({...});
const reservation: TickerReservation = await apiAlice.getTickerReservation({
    "ticker": "ACME"
});
```

```javascript
const apiAlice = await Polymesh.connect({...});
const reservation = await apiAlice.getTickerReservation({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

You will note that the class `TickerReservation`, just like the transaction queue, keeps a [`protected context: Context`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/tickerreservation#properties-1). This `context` in turn keeps a [`polymeshApi`](https://developers.polymath.network/polymesh-sdk-api-reference/classes/context#properties-1). It is in there that we find the implicit knowledge that it is `alice`'s account that is asking for the next actions. If it were any other **account** that had called `getTickerReservation`, this other account would not be able to follow up with a `.createToken` command because it doesn't own the reservation.

With our `reservation` in memory, and 10,000 POLYX in `alice`'s wallet, which is the cost of creation of one security token, we now can create it:

<MultiCodeBlock>

```typescript
const tokenQueue: TransactionQueue<SecurityToken> = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": KnownTokenType.EquityPreferred,
    "isDivisible": false
});
```

```javascript
const tokenQueue = await reservation.createToken({
    "name": "ACME Co",
    "tokenType": "EquityPreferred",
    "isDivisible": false
});
```

</MultiCodeBlock>

We have another queue, so, as we did before:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await tokenQueue.run();
```

```javascript
const token = await tokenQueue.run();
```

</MultiCodeBlock>

Implicit in the creation of this token is that Alice, as a private individual, is **both the token's owner and its primary issuance agent (PIA)**. We were satisfied with this situation only up to this point. Now this needs to change.

This `token` instance will not always be in memory, so if we wanted to fetch it at a later date, we would do:

<MultiCodeBlock>

```typescript
const token: SecurityToken = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
```

```javascript
const token = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
```

</MultiCodeBlock>

## Secondary keys

Now we assume that ACME has gone through CDD and has an account, complete with a private key and its mnemonic, which, in a mirror fashion of that of Alice gives us:

<MultiCodeBlock>

```typescript
const apiAcme: Polymesh = await Polymesh.connect({
    "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word21 word22 ..."
});
const acme: Identity = await apiAcme.getCurrentIdentity();
const acmeDid: string = acme.did;
```

```javascript
const apiAcme = await Polymesh.connect({
    "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word21 word22 ..."
});
const acme = await apiAcme.getCurrentIdentity();
const acmeDid = acme.did;
```

</MultiCodeBlock>

On her end, Alice, has created another mnemonic for a private key she intends to use when she acts as the CEO of ACME. Again:

<MultiCodeBlock>

```typescript
const apiCeo: Polymesh = await Polymesh.connect({
    "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word31 word32 ..."
});
```

```javascript
const apiCeo = await Polymesh.connect({
    "nodeUrl": "wss://testnet-rpc.polymesh.live", // For instance, or the proper network
    "accountMnemonic": "word31 word32 ..."
});
```

</MultiCodeBlock>

At this point, `apiCeo` has no associated account. It is a signing key in search of an account. Alice first needs to get her public key:

<MultiCodeBlock>

```typescript
const pubCeo: string = apiCeo.getAccount().address;
```

```javascript
const pubCeo = apiCeo.getAccount().address;
```

</MultiCodeBlock>

Then she needs to send this `pubCeo` information to the computer that holds `apiAcme`. When this is done, the company can invite her to be a secondary key:

<MultiCodeBlock>

```typescript
const acme: Identity = await apiAcme.getCurrentIdentity();
await acme.inviteAccount({
    "targetAccount": pubCeo
});
```

```javascript
const acme = await apiAcme.getCurrentIdentity();
await acme.inviteAccount({
    "targetAccount": pubCeo
});
```

</MultiCodeBlock>

With the invitation sent out into the blockchain, back at her computer, Alice, with knowledge of ACME account's number, `acmeDid`, can do:

<MultiCodeBlock>

```typescript
const ceoAccount: Account = apiCeo.getAccount();
const pendingAuthorizations: AuthorizationRequest[] = await ceoAccount.authorizations.getReceived();
const acmeAuthorization: AuthorizationRequest = pendingAuthorizations
    .find((pendingAuthorization: AuthorizationRequest) => {
        return pendingAuthorization.issuer.did === acmeDid;
    });
const acceptQueue: TransactionQueue<void> = await acmeAuthorization.accept();
await acceptQueue.run();
```

```javascript
const ceoAccount = apiCeo.getAccount();
const pendingAuthorizations = await ceoAccount.authorizations.getReceived();
const acmeAuthorization = pendingAuthorizations
    .find((pendingAuthorization) => {
        pendingAuthorization.issuer.did === acmeDid;
    });
const acceptQueue = await acmeAuthorization.accept();
await acceptQueue.run();
```

</MultiCodeBlock>

With this done, `apiCeo` now allows Alice to properly act as the CEO, on behalf of ACME.

## Token ownership transfer

With the keys and accounts finally set right, it is time for Alice to fix the token situation, and transfer its ownership to ACME.

Since it is Alice the individual who owns the token, she has to go back to using her personal account.

<MultiCodeBlock>

```typescript
const token: SecurityToken = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
const transferQueue: TransactionQueue<SecurityToken> = await token.transferOwnership({
    "target": acmeDid
});
await transferQueue.run();
```

```javascript
const token = await apiAlice.getSecurityToken({
    "ticker": "ACME"
});
const transferQueue = await token.transferOwnership({
    "target": acmeDid
});
await transferQueue.run();
```

</MultiCodeBlock>

With the authorisation recorded in the blockchain, and on the way, Alice can stay on the same computer and switch from her personal identity to her identity as the CEO of ACME to accept the authorisation.

She first needs to recall her personal account number, or `did`.

<MultiCodeBlock>

```typescript
const alice: Identity = await apiAlice.getCurrentIdentity();
const aliceDid: string = alice.did;
```

```javascript
const alice = await apiAlice.getCurrentIdentity();
const aliceDid string = alice.did;
```

</MultiCodeBlock>

So she can narrow down the authorisation, instead of blindly accepting whatever is in the pipeline.

<MultiCodeBlock>

```typescript
const pendingAuthorizations: AuthorizationRequest[] = await ceoAccount.authorizations.getReceived();
const transferAuthorization: AuthorizationRequest = pendingAuthorizations
    .find((pendingAuthorization: AuthorizationRequest) => {
        return pendingAuthorization.issuer.did === aliceDid;
    });
const acceptQueue: TransactionQueue<void> = await transferAuthorization.accept();
await acceptQueue.run();
```

```javascript
const pendingAuthorizations = await ceoAccount.authorizations.getReceived();
const transferAuthorization = pendingAuthorizations
    .find((pendingAuthorization) => {
        return pendingAuthorization.issuer.did === aliceDid;
    });
const acceptQueue = await transferAuthorization.accept();
await acceptQueue.run();
```

</MultiCodeBlock>

With this, the token is rightfully owned by ACME the company.

## Compliance

We are not done yet with the token, though.

As the CEO, Alice still needs to do one more step, that is, to define the conditions of ownership. Namely, require any account who acquires the token to not have a jurisdictional attestation of <span title="Elbonia doesn't appear in the CountryCode enum">Liechtenstein</span>. An exception will be made for the primary issuance agent, who is simply used as a conduit and can send to anyone.

We use ACME's account as the KYC service provider, but realistically, it should be another account.

<MultiCodeBlock>

```typescript
const acmeCompliance: Compliance = token.compliance;
const acmeRequirements: Requirements = acmeCompliance.requirements;
const acme: Identity = await apiCeo.getCurrentIdentity();
const setRequirementsQueue: TransactionQueue<SecurityToken> = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": ConditionTarget.Sender,
                "type": ConditionType.IsPrimaryIssuanceAgent
            }
        ],
        [
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsPresent,
                "claim": {
                    "type": ClaimType.KnowYourCustomer,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": acme.did,
                    "trustedFor": [ClaimType.KnowYourCustomer]
                }]
            },
            {
                "target": ConditionTarget.Receiver,
                "type": ConditionType.IsAbsent,
                "claim": {
                    "type": ClaimType.Jurisdiction,
                    "code": CountryCode.Li,
                    "scope": {
                        "type": ScopeType.Ticker,
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": acme.did,
                    "trustedFor": [ClaimType.Jurisdiction]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

```javascript
const acmeCompliance = token.compliance;
const acmeRequirements = acmeCompliance.requirements;
const acme = await apiCeo.getCurrentIdentity();
const setRequirementsQueue = await acmeRequirements.set({
    "requirements": [
        [
            {
                "target": "Sender",
                "type": "IsPrimaryIssuanceAgent"
            }
        ],
        [
            {
                "target": "Receiver",
                "type": "IsPresent",
                "claim": {
                    "type": "KnowYourCustomer",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": acme.did,
                    "trustedFor": ["KnowYourCustomer"]
                }]
            },
            {
                "target": "Receiver",
                "type": "IsAbsent",
                "claim": {
                    "type": "Jurisdiction",
                    "code": "Li",
                    "scope": {
                        "type": "Ticker",
                        "value": token.ticker
                    }
                },
                "trustedClaimIssuers": [{
                    "identity": acme.did,
                    "trustedFor": ["Jurisdiction"]
                }]
            }
        ]
    ]
});
const updatedToken: SecurityToken = await setRequirementsQueue.run();
```

</MultiCodeBlock>

With this, the token is _originated_. Nobody, including Alice under her personal account, is yet a holder of any amount of the security token, though, we remedy that in the next chapter when we tackle **distribution**.

## Links

- SDK: https://developers.polymath.network/classic-sdk/globals
